---
title: "Spatial Regression of Stormwater Pollutants"
author: "Christian Nilsen"
output:
  html_document:
    s8data_print: paged
---
#To do: 
*add in rainfall 
*clean up eeIncidies
*add more exploratory section
*follow Tufts example
*add bibilography
*select a mixed effects model

#Introduction
This notebook demonstrates spatial regression of stormwater pollutant data for Puget Sound. It combines stormwater outfall monitoring data with spatial regression to predict pollutant concentrations across Puget Sound. 

The stormwater outfall data is available from the Department of Ecology at
https://data.wa.gov/Natural-Resources-Environment/Municipal-Stormwater-Permit-Outfall-Data/d958-q2ci
It uses the Socrata REST api in the form of 

https://data.wa.gov/resource/d958-q2ci.json?parameter=Copper%20-%20Water%20-%20Total




```{r include=FALSE}
library(RSocrata)

if (!require('NADA')) install.packages('NADA')
if (!require('RSocrata')) install.packages('RSocrata')
if (!require('Hmisc')) install.packages('Hmisc')
if (!require('tidyverse')) install.packages('tidyverse')
if (!require('formattable')) install.packages('formattable')
if (!require('kableExtra')) install.packages('kableExtra')
if (!require('survival')) install.packages('survival')

if (!require('PerformanceAnalytics')) install.packages("PerformanceAnalytics")
library(NADA)
library(RSocrata)
library(dplyr)
library(Hmisc)
library(formattable)
library(survminer)
library(tidyverse)
library(kableExtra)
library(survival)
library(PerformanceAnalytics)
```
Get data
```{r}
url <- ("https://data.wa.gov/resource/rc6b-fvgb.json")
parameter <- 'Copper - Water - Total'
#construct the SQL call 
#apiCall <- paste0(url,"?$where=Result_Data_Qualifier<>'REJ' AND parameter= ","'",parameter,"'")
apiCall <- paste0(url,"?$where=parameter= ","'",parameter,"'")
data <-as_tibble(read.socrata(apiCall))
data <- (filter(data,!result_data_qualifier %in% 'REJ'))
data <- type.convert(data)

```
Looks OK

```{r echo=TRUE}
#read in spatial data and join


s8data <- data %>% 
   dplyr::select(location_id,study_id, parameter,season,new_result_value,nondetect_flag, new_result_units,field_collection_start_date,type) #sampling data


luLookup <-
 (read.csv("Data/luLookup.csv",  na = "NA")) #land use data
eeIndicies <-
  read.csv("Data/eeIndiciesNorm.csv") #spatial parameters
s8xy <-
  read.csv("Data/s8xy.csv") #xy coordinates of sampling locations


colnames(s8data)[colnames(s8data)=="location_id"] <- "Location"
```


```{r echo=TRUE}
s8data <- s8data %>%
    merge(eeIndicies, by = "Location") %>%
    merge(luLookup, by = "Location") %>%
    merge(s8xy, by = "Location") 
#s8data <- as_tibble(s8data)
s8data$Year <- with(s8data, format(as.Date(field_collection_start_date),"%Y"))

#Trim location names so that Port of Seattle outfall locations are the same (all same study)
s8data$Location <- substr(s8data$Location, 1, 12)
#Plot data to view
plot.title <- paste0(s8data$parameter, ' (',s8data$new_result_units,')')
plot <- ggplot(data = s8data) + 
  geom_point(mapping = aes(x = 1, y = new_result_value, color = study_id), position = 'jitter')  
plot+ggtitle(plot.title)
```
Looks good. Lets look at how concentration are correleated with landuse. 



```{r}
s8data$Loc.Year <- paste0(s8data$Location, '-', s8data$Year)

# Plot by study 
plot <- ggplot(s8data, aes(study_id,new_result_value, fill = study_id)) + 
  geom_boxplot()+theme(legend.position = "none")+scale_y_log10()+ggtitle(plot.title)
 
   
plot
```
Explore the data more 
```{r}

# Plot by type 
plot <- ggplot(s8data, aes(type,new_result_value, fill = study_id)) + 
  geom_boxplot()+theme(legend.position = "none")+scale_y_log10()+ggtitle(plot.title)
 
   
plot
```
Let's see if there is a distribution we can use

```{r}
library(MASS)
library(qualityTools)
#normal distribution
x <- s8data$new_result_value
qqPlot(x, "log-normal")
qqPlot(x, "weibull")
qqPlot(x, "gamma")
qqPlot(x, "normal")
qqPlot(x, 'exponential')
qqPlot(log(x+1), "weibull")#this is the Gumbell distribution



```
Data are not normally distributed, mixed effects modeling cannot have normal distribution assumptions for random effects. 

assume a weibell or gamma distribution for mixed effects. These are both forms of the exponetional function

PQL <- glmmPQL(Aggression.t ~ Relation + Season, ~1 | Observer/Test.ID, family = gaussian(link = "log"),
    data = recog, verbose = FALSE)
    
```{r}
PQL <- glmmPQL(new_result_value ~ roads + Impee + pm25 + SFR + COM, data=s8data, random = ~1|study_id,family = Gamma(link = 'log'))

summary(PQL)
```


```{r}
plot(PQL, log(new_result_value) ~ fitted(.), abline = c(0,1))
```
 COM, data=s8data, random = ~1|study_id) 
plot(Orthodont,asp="fill") ## plot responses by individual


    

Since the data set has mixed detection limits, we will use the kaplan-meier estimator to evaluate median values

```{r echo=FALSE}
#first determine which are censored and which are not 
obs      <- as.numeric(s8data$new_result_value)
censored <-as.logical(s8data$nondetect_flag)
groups = as.factor(s8data$Location)
KM = cenfit(obs, censored, groups)
b <- as.data.frame(median(KM))
KM.medians <- tibble(site = row.names(b), median = (b$`median(KM)`))
kable(KM.medians)

```


Look at landuses 
```{r echo=TRUE}
cor.data <- (cbind(s8data$new_result_value, s8data[, 18:22])) #land uses
chart.Correlation(cor.data, histogram=FALSE, method = 'pearson')
cor.matrix <- rcorr(as.matrix(cor.data),s8data$nondetect_flag)
r<- (cor.matrix$r)[,1]
P<- (cor.matrix$P)[,1]
table <- (cbind(r,P))
kable(table)

```
Look at other indices 
```{r}
cor.data <- cbind(s8data$new_result_value, s8data[, 10:16], s8data$age, s8data$elev) #indicies from earth engine
chart.Correlation(cor.data, histogram=FALSE, method = 'pearson')
cor.matrix <- rcorr(as.matrix(cor.data),s8data$nondetect_flag)
```

Imperviousness is the highest correleated, followed by elevation, then age and ndvi mean. 

Let's choose 0.25 as the cutoff for correlation. This gives the following as variables to use: 
*Landuse 
  *Percent COM
  *Percent SFR
*Indicies
  *imperviousness
  *ndbi
  *roads
```{r}
r<- (cor.matrix$r)[,1]
P<- (cor.matrix$P)[,1]
table <- (cbind(r,P))
kable(table)
```

Begin linear model  (ignore non-detects for now)
```{r}
library(nlme)
fit1 <- gls(new_result_value ~ COM + SFR + Impee + ndbi +roads, data=s8data,method="ML")
summary(fit1)


```
Begin mixed effect model
```{r}
#try loc and year as grouping factors
fit2 <- lme(new_result_value ~ COM + SFR + Impee + ndbi +roads, data=s8data, random = ~1|Loc.Year,method="ML")  
summary(fit2)
```

Begin robust model

```{r}
fit4 <- rlm(new_result_value ~ COM + SFR + Impee + ndbi +roads, data=s8data)  
summary(fit4)
```

Display ANOVA table
```{r}
fit3 <- lme(log(new_result_value) ~ Impee  +roads, data=s8data, random = ~1|Loc.Year,method="ML") 



```

Fit2 has a slightly lower AIC Begin forward selection 

```{r}
plot.lme(fit3)
plot(fit3, log(new_result_value) ~ fitted(.), abline = c(0,1))
# }

library(leaps)
library(AICcmodavg)

Cand.models<-list()
Cand.models[[1]] <- fit2
Cand.models[[2]] <- fit3
fit4 <- lme(log(new_result_value) ~ Impee  +roads, data=s8data, random = ~1|Loc.Year,method="ML") 
#create a vector of names to trace back models in set
Modnames<-paste("mod", 1:length(Cand.models), sep="")

leaps<-regsubsets(log(new_result_value) ~ COM + SFR + Impee + ndbi + roads, data=s8data,method = 'forward')
# view results 
summary(leaps)
# plot a table of models showing variables in each model.
# models are ordered by the selection statistic.
#layout(matrix(c(1, 2), 2, 1)) # optional 2 graphs/page
plot(leaps,scale="adjr2")
plot(leaps,scale="bic")
```


```{r}
#generate AICc table
bictab(cand.set = Cand.models, modnames = Modnames, sort=TRUE)


```
Next try quantile regression and see if any better. 
Add in annual precipitation to see if any difference. 

```{r}
# (examples in Chap 12 of the NADA book)
library(dplyr)   
library(flexsurv)
 data(TCEReg)
 
 # select variables v1, v2, v3
myvars <- c("new_result_value", "Impee","roads", "nondetect_flag")
df <- as.data.frame(s8data[myvars])
df$nondetect_flag <- as.logical(df$nondetect_flag)


fit9 <-  with(df, cenreg(Cen(new_result_value, nondetect_flag)~Impee+roads))
 
# plot(fit9, log(new_result_value) ~ fitted(.), abline = c(0,1))
(fit9)
plot(predict(fit9, c(0.2,0.5)))
```

```{r}
library(quantreg)
Curv
```

